using System;
using System.Linq;
using System.Text;

namespace Levenshtypo;

// The main `State` class was generated by Levenshtypo.Generator

internal class Distance1LevenshteinLevenshtomaton<TCaseSensitivity> : Levenshtomaton where TCaseSensitivity : struct, ICaseSensitivity<TCaseSensitivity>
{
    private string _s;
    private Rune[] _sRune;

    public Distance1LevenshteinLevenshtomaton(string s) : base(s, 1)
    {
        _s = s;
        _sRune = s.EnumerateRunes().ToArray();
    }

    public override bool IgnoreCase => typeof(TCaseSensitivity) == typeof(CaseInsensitive);

    public override LevenshtypoMetric Metric => LevenshtypoMetric.Levenshtein;

    public override T Execute<T>(ILevenshtomatonExecutor<T> executor) => executor.ExecuteAutomaton(StartSpecialized());

    public override bool Matches(ReadOnlySpan<char> text) => DefaultMatchesImplementation(text, StartSpecialized());

    private State StartSpecialized() => State.Start(_sRune);

    public override LevenshtomatonExecutionState Start() => LevenshtomatonExecutionState.FromStruct(StartSpecialized());
    private readonly struct State : ILevenshtomatonExecutionState<State>
    {
        private static ReadOnlySpan<short> TransitionsD0 => [0x02, -1, -1, -1, -1];
        private static ReadOnlySpan<bool> FinalsD0 => [true, false, true, false, false];
        private static ReadOnlySpan<short> TransitionsD1 => [0x01, 0x100, -1, 0x102, -1, 0x102, -1, -1, -1, -1];
        private static ReadOnlySpan<bool> FinalsD1 => [true, true, false, false, false];
        private static ReadOnlySpan<short> TransitionsD2 => [0x01, 0x03, 0x100, 0x100, -1, 0x202, 0x102, 0x101, -1, -1, 0x102, 0x102, -1, 0x202, 0x102, 0x101, -1, -1, 0x102, 0x102];
        private static ReadOnlySpan<bool> FinalsD2 => [false, false, false, true, true];
        private static ReadOnlySpan<short> TransitionsD3 => [0x01, 0x01, 0x03, 0x03, 0x100, 0x100, 0x100, 0x100, -1, -1, 0x202, 0x202, 0x102, 0x102, 0x101, 0x101, -1, -1, -1, -1, 0x102, 0x102, 0x102, 0x102, -1, 0x302, 0x202, 0x201, 0x102, 0x104, 0x101, 0x103, -1, 0x302, -1, 0x302, 0x102, 0x104, 0x102, 0x104];
        private static ReadOnlySpan<bool> FinalsD3 => [false, false, false, false, false];

        private readonly Rune[] _sRune;
        private readonly int _sIndex;
        private readonly int _state;

        private State(Rune[] sRune, int state, int sIndex)
        {
            _sRune = sRune;
            _state = state;
            _sIndex = sIndex;
        }

        internal static State Start(Rune[] sRune) => new State(sRune, 0, 0);

        public bool MoveNext(Rune c, out State next)
        {
            var s = _sRune;
            var sIndex = _sIndex;

            short encodedNext;

            switch (s.Length - sIndex)
            {
                case 0:
                    {
                        var vector = 0
                            ;

                        encodedNext = TransitionsD0[_state * 1 + vector];

                        break;
                    }
                case 1:
                    {
                        var vector = 0
                            | (default(TCaseSensitivity).Equals(c, s[sIndex + 0]) ? 1 : 0)
                            ;

                        encodedNext = TransitionsD1[_state * 2 + vector];

                        break;
                    }
                case 2:
                    {
                        var vector = 0
                            | (default(TCaseSensitivity).Equals(c, s[sIndex + 0]) ? 2 : 0)
                            | (default(TCaseSensitivity).Equals(c, s[sIndex + 1]) ? 1 : 0)
                            ;

                        encodedNext = TransitionsD2[_state * 4 + vector];

                        break;
                    }
                default:
                    {
                        var vector = 0
                            | (default(TCaseSensitivity).Equals(c, s[sIndex + 0]) ? 4 : 0)
                            | (default(TCaseSensitivity).Equals(c, s[sIndex + 1]) ? 2 : 0)
                            | (default(TCaseSensitivity).Equals(c, s[sIndex + 2]) ? 1 : 0)
                            ;

                        encodedNext = TransitionsD3[_state * 8 + vector];

                        break;
                    }
            }

            if (encodedNext >= 0)
            {
                // format:
                // top bit reserved for negative sign
                // next 7 bits reserved for offset (max = 64 is more than enough)
                // next 8 bits is the nextState
                int nextState = encodedNext & 0xFF;
                int offset = (encodedNext >> 8) & 0x3F;
                next = new State(_sRune, nextState, sIndex + offset);
                return true;
            }

            next = default;
            return false;
        }

        public bool IsFinal =>
            (_sRune.Length - _sIndex) switch
            {
                0 => FinalsD0[_state],
                1 => FinalsD1[_state],
                2 => FinalsD2[_state],
                _ => FinalsD3[_state],
            };
    }

}
